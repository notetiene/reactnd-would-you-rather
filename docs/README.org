#+title: Udacity ReactND Would You Rather Project Notes
#+author: Etienne Prud’homme
#+descrition: Second Udacity React Nano Degree project
#+keywords: react, redux
#+filetags: Udacity ReactND
#+SETUPFILE: https://fniessen.github.io/org-html-themes/setup/theme-readtheorg.setup

* Would You Rather Project

  Would you rather is a web application that includes simple polls made
  by its users.  The form of the polls are as follow:

#+begin_quote
Would you rather [option A] or [option B]?
#+end_quote


** Overview
*** Goals of this project

 * Better understanding of React and Redux
 * Practice improving predictability of the application’s state
 * Establishing strict rules for interacting with the store
 * Identify which state should live in Redux
 * Identify which state should live in React components

*** Starter code
    The starter code consists of a =_DATA.js= file which contains a
    fake database and functions to interact with it.

** App functionality
*** TODO Impersonating
    There should be a way to impersonate a existing user.
**** TODO Allow log in and log out
**** TODO On log in, show home page
**** TODO Current user should be shown
*** TODO Permissions
**** TODO User must be logged-in to show pages

     If someone tries to navigate anywhere by entering the address in
     the address bar, the user *is asked to sign in* and then the
     requested page is shown.

*** TODO Home page
#+caption: Question page
[[file:images/home_page.png]]
**** TODO Located at the root ~/~
**** TODO Show answered and unanswered questions
     There should two tabs.
***** TODO Unanswered questions shown by default
**** TODO Show in order
     Show most recent (top) to least recent (bottom).
**** TODO A poll can be clicked
     When clicking on the poll, show the poll page.

*** TODO Question page
**** TODO Located at ~/questions/:question_id~
     Where =:question_id= is the id of the poll/question.
**** TODO Show content
***** Unanswered question
#+caption: Question page (unanswered)
[[file:images/question_page_unanswered.png]]

The unanswered question must contain:
 * [ ] The text =Would you rather=
 * [ ] Avatar of the user who posted the question
 * [ ] Two options

****** When voting
 * [ ] The answer must be recorded
 * [ ] All the information about the question should be displayed
   (answered question)
 * [ ] Users can only vote once and cannot change their answer
 * [ ] When the user comes back to the home page, the question should
   be in the answered section

***** Answered question
#+caption: Question page (unanswered)
[[file:images/question_page_answered.png]]

The answered question must contain:
 * [ ] Text of the option
 * [ ] Number of people who voted for that option
 * [ ] Percentage of people who voted for that option
 * [ ] The option the logged-in user choose

**** TODO Show error if poll doesn’t exist
     Show an error page (404) if the poll doesn’t exist.
*** TODO New question page
**** TODO Located at ~/add~
**** TODO Show content
The page must contain:
 * [ ] The text =Would You Rather=
 * [ ] A form of two options

The page should:
 * [ ] Have indication that the input are required
 * [ ] Have a button submit button that is disabled when the two input are
   not correct, but becomes enabled when the form is correct
 * [ ] Submit the answer when pressing enter
 * [ ] Both input should not be empty or with white space only

**** TODO Handle new question
 * [ ] The new question should appear in the correct category on the
   home page
*** TODO Leaderboard
**** TODO Located at ~/leaderboard~
**** TODO Show content
The list of users and the following:
 * [ ] User’s name
 * [ ] User’s avatar
 * [ ] Number of question the user asked
 * [ ] Number of question the user answered
 * [ ] Sorted by their score (questions + answers)

It should contain the following:
 * [ ] Sum of score
 * [ ] Trophies based on score
   * [ ] No trophy if max score is zero

*** TODO Navbar
    Add a navbar to navigate between:

 * [ ] Home page
 * [ ] New question page
 * [ ] Leader board
 * [ ] Log in or Log out
** App architecture
*** Most state should be managed by Redux
Read: [[https://github.com/reactjs/redux/issues/1287][choosing between Redux’s store and React’s state]]

*** The store is the single source of truth
**** Components should reference to Redux
**** No direct API call in component’s lifecycle methods
     Updates should be triggered by dispatching action creators.
*** Application should be structured
*** Components should be modular and resusable
** App components logic
*** Data architecture
#+begin_src plantuml :file images/the_store.png
skinparam {
    titleBorderRoundCorner 15
    titleBorderThickness 2
    titleBorderColor black
    handwritten true
    shadowing true
    ArrowColor Olive
}
left to right direction

title =Redux Store Tree

rectangle authedUser
rectangle users
rectangle questions

rectangle "Store\r<img:https://raw.githubusercontent.com/Roemer/plantuml-office/master/office2014/Databases/database_mini_2_blue.png>" as redux

redux -- authedUser
redux -- users
redux -- questions
#+end_src

#+caption: The Store
#+RESULTS:
[[file:images/the_store.png]]

The store contains 3 main properties.

 * =authedUser= that is a =String= containing a *valid* user ID.
 * =users= that is a complex object
 * =questions= that is a complex object

**** =authedUser=
**** =users=

#+begin_src plantuml :file images/users_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      ArrowColor Olive
  }

  title =Structure of <u>users</u> object

  left to right direction
  rectangle "Users\r<img:https://raw.githubusercontent.com/Roemer/plantuml-office/master/office2014/Users/users_blue.png>" as users

  package sarahedo [{
      <i>id</i>: "sarahedo",
      <i>name</i>: "Sarah Edo",
      <i>avatarURL</i>: "/avatars/user3.svg",
      <i>answers</i>: {
          <i>'8xf0y6ziyjabvozdd253nd'</i>: 'optionOne',
          <i>'6ni6ok3ym7mf1p33lnez'</i>: 'optionTwo',
          <i>'am8ehyc8byjqgar0jgpub9'</i>: 'optionTwo',
          <i>'loxhs1bqm25b708cmbf3g'</i>: 'optionTwo',
      }
  }]
  package tylermcginnis [
  ...
  ]
  package johndoe [
  ...
  ]

  users --> tylermcginnis
  users --> johndoe
  users --> sarahedo
#+end_src

#+caption: Users structure
#+RESULTS:
[[file:images/users_structure.png]]

**** =questions=

#+begin_src plantuml :file images/questions_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      ArrowColor Olive
  }

  title =Structure of <u>questions</u> object

  left to right direction
  rectangle "Questions\r<img:https://raw.githubusercontent.com/Roemer/plantuml-office/master/office2014/Users/communications.png>" as questions

  package 8xf0y6ziyjabvozdd253nd [{
      <i>id</i>: "8xf0y6ziyjabvozdd253nd",
      <i>author</i>: "sarahedo",
      <i>timestamp</i>: 1467166872634,
      <i>optionOne</i>: {
          <i>'votes'</i>: ['sarahedo'],
          <i>'text'</i>: 'have horrible short term memory',
      }
      <i>optionTwo</i>: {
          <i>'votes'</i>: [],
          <i>'text'</i>: 'have horrible long term memory',
      }
  }]
  package 6ni6ok3ym7mf1p33lnez [
  ...
  ]
  package am8ehyc8byjqgar0jgpub9 [
  ...
  ]
  package loxhs1bqm25b708cmbf3g [
  ...
  ]
  package vthrdm985a262al8qx3do [
  ...
  ]
  package xj352vofupe1dqz9emx13r [
  ...
  ]

  questions --> 8xf0y6ziyjabvozdd253nd
  questions --> 6ni6ok3ym7mf1p33lnez
  questions --> am8ehyc8byjqgar0jgpub9
  questions --> loxhs1bqm25b708cmbf3g
  questions --> vthrdm985a262al8qx3do
  questions --> xj352vofupe1dqz9emx13r
#+end_src

#+caption: Questions structure
#+RESULTS:
[[file:images/questions_structure.png]]

*** App Components structure
#+begin_src plantuml :file images/app_components_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      ArrowColor Olive
  }

  title =Structure of <i>App</i> <u>components</u>
  left to right direction

  rectangle React {
      rectangle PersistGate
      rectangle App
      rectangle ConnectedRouter
      rectangle Container as Container
      rectangle NavBar
      rectangle Routes [
          routes
      ]

      PersistGate --> App : (for Redux persistance)
      App --> ConnectedRouter
      ConnectedRouter --> Container
      Container --> NavBar
      Container --> Routes
  }
#+end_src

#+caption: App Components structure
#+RESULTS:
[[file:images/app_components_structure.png]]

*** Routed Components Structure
#+begin_src plantuml :file images/routes_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      ArrowColor Olive
  }

  title =Structure of <i>routes</i>
  left to right direction

  rectangle App {
      rectangle routes {
          rectangle Home
          rectangle Leaderboard
          rectangle NewQuestion
          rectangle Question
          rectangle SignIn
          rectangle User
          rectangle PageNotFound

          cloud "/" as home
          cloud "/leaderboard" as leaderboard
          cloud "/add" as newquestion
          cloud "/signin" as signin
          cloud "/question::id" as question
          cloud "/user::id" as user
          cloud "/" as pagenotfound

          home --> Home : exact match
          leaderboard --> Leaderboard : exact match
          newquestion --> NewQuestion : exact match
          signin --> SignIn : exact match
          question ..> Question : matches /user:‘id’
          user ..> User : matches /question:‘id’
          pagenotfound ..> PageNotFound : matches anything else
      }
  }
#+end_src
#+caption: Structure of routes
#+RESULTS:
[[file:images/routes_structure.png]]

**** Behaviour of routed component
The list of routed components is the following:
 - =Home=
   - Login is required to view the page
     - Otherwise redirect to SignIn
 - =Leaderboard=
   - Login is required to view the page
     - Otherwise redirect to =SignIn=
 - =NewQuestion=
   - Login is required to view the page
     - Otherwise redirect to SignIn
 - =Question=
   - Login is required to view the page
     - Otherwise redirect to =SignIn=
   - When the matched URL contains an invalid question, redirect to
     =PageNotFound=
 - =User=
   - Login is required to view the page
     - Otherwise redirect to =SignIn=
   - When the matched URL contains an invalid user, redirect to
     =PageNotFound=
 - =SignIn=
 - =PageNotFound=

Since many pages (or component) require the user to be logged-in, we
must use a compone that will provide that behaviour.

#+begin_src plantuml :file images/routes_to_components_behaviour.png
  skinparam {
      titleBorderRoundCorner 15

      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Behaviour of <i>routed</i> <u>components</u>
  left to right direction

  rectangle "Directory tree: <font:Courier>src/components/layout/" as Struct {
      rectangle Home [
      ""**Home**""
      ]
      rectangle Leaderboard [
      ""**Leaderboard**""
      ]
      rectangle NewQuestion [
      ""**NewQuestion**""
      ]
      rectangle Question [
      ""**Question**""
      ]
      rectangle User [
      ""**User**""
      ]
      rectangle SignIn [
      ""**SignIn**""
      ]
      rectangle PageNotFound [
      ""**PageNotFound**""
      ]

      Question -|> PageNotFound : when question doesn’t exist
      User -|> PageNotFound : when user doesn’t exist
  }

  rectangle "Login is required" as LoginRequired
  Home --|> LoginRequired
  Leaderboard --|> LoginRequired
  NewQuestion --|> LoginRequired
  Question --|> LoginRequired
  User --|> LoginRequired

  LoginRequired --> SignIn : redirects to
#+end_src
#+caption: Behaviour of routed components
#+RESULTS:
[[file:images/routes_to_components_behaviour.png]]

*** =Home= Component
The =Home= component will provide two list of questions:
 - Unanswered questions
 - Answered questions

Two tabs will be used while showing unanswered questions by default.
This behaviour will be included in the =QuestionList= component.

**** Overview
#+caption: Mockup of =Home= component
#+RESULTS:
[[file:images/home_overview.png]]

This is the view of the =home= component.

1. is a =Question= component
2. is a =Tab.Menu= component
3. is the =Tab.Segment= component
4. is a =QuestionExcerpt= component

**** Data of =Home=
This component will be a connected component to the Redux store.  The
following state properties will be used for mapping:
 - =questions=
 - =authedUser=

The properties mapped will be the following:
 - =answeredQuestions=
   - Obtained by filtering =questions= the current =authedUser= has
     answered and returning the question’s ID property.
 - =unansweredQuestions=
   - Obtained by filtering =questions= the current =authedUser= has
     not answered and returning the question’s ID property.

#+begin_src plantuml :file images/home_component_data.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Data of component: ""Home""
  left to right direction

  class Home {
      == Connected Props ==
      questionIDList : answeredQuestions
      ..
      questionIDList: unansweredQuestions
  }
#+end_src
#+caption: Data of Home component
#+RESULTS:
[[file:images/home_component_data.png]]

***** =Questions= mapping operations
The =answeredQuestions= will be calculated by first transforming the
=questions= object to a list.  The given list will be filtered by the
predicate that the =authedUser= is included in one of the two options
of the question.  The remaining list will only return the question
IDs.

Likewise =unansweredQuestions= will be calculated by first
transforming the =questions= object to a list.  The given list will be
filtered by the predicate that the =authedUser= is *not* included in
one of the two options of the question.  The remaining list will only
return the question IDs

#+caption: Mapped state properties to the =Home= component properties
#+begin_src js
  function mapStateToProps({ questions, authedUser }) {
    const answeredQuestions = Object.values(questions)
          .filter((question) => question.optionOne.votes.includes(authedUser)
                  || question.optionTwo.votes.includes(authedUser))
          .map((question) => question.id);
    const unansweredQuestions = Object.values(questions)
      .filter((question) => !question.optionOne.votes.includes(authedUser)
              && !question.optionTwo.votes.includes(authedUser))
      .map((question) => question.id);
    return {
      answeredQuestions,
      unansweredQuestions,
    };
  }
#+end_src

**** Tree of =Home=
The following components components will be children of =Home=
 - =Body= for layout
   - =QuestionList= to show answered and unanswered questions.  Both
     properties passed to the component will be a list of question IDs
     as string

#+begin_src plantuml :file images/home_component_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Tree structure of component: ""Home""
  left to right direction

  rectangle Home [
  ""**Home**""
  ]
  rectangle Body [
  ""**Body**""
  ]
  rectangle QuestionList [
  ""**QuestionList**""
  ==
  === Passed Props:
  ..
  ""unansweredQuestions""
  <size:13>List of unanswered question ids
  ..
  ""answeredQuestions""
  <size:13>List of answered question ids
  ]

  Home --> Body
  Body --> QuestionList
#+end_src
#+caption: Structure of Home component
#+RESULTS:
[[file:images/home_component_structure.png]]

*** =Leaderboard= Component
The =Leaderboard= component will contain a list of users sorted by
their rank.  Each user will be clickable to show their page.

**** Overview
#+caption: Mockup of =Leaderboard= component
#+RESULTS:
[[file:images/leaderboard_overview.png]]

This is the view of the =Leaderboard= component.

 1. will be a =UserCard= component
 2. will be a =ScoreTable= component
 3. will be a =RankLabel= component
 4. will be a =UserScore= component
 5. might be a =UserAvatar= component

**** Data of =Leaderboard=
This component will be a connected component to the Redux store.  The
following state properties will be used for mapping:
 - =questions=
 - =users=

The properties mapped will be the following:
 - users
   - Obtained by sorting the users by their score (generated in the
     mapping function) and a corresponding rank will be added.

#+begin_src plantuml :file images/leaderboard_component_data.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Data of component: ""Leaderboard""
  left to right direction

  class Leaderboard {
      == Connected Props ==
      UsersObject : users
  }
#+end_src
#+caption: Data of =Leaderboard= component
#+RESULTS:
[[file:images/leaderboard_component_data.png]]

***** =Leaderboard= mapping operations
First, the =users= object will be transformed to a list from the
object’s values.  This allows sorting users more easily.

In order to calculate the score for each user, the number of answered
questions and asked questions will be calculated.  The score is both
numbers added.  Both numbers can be calculated by looking into the
=questions= object.

While sorting the users by their newly added score (by spreading the
user with the score), generate a new set containing all the scores
sorted.  By converting the new set to a list, we can lookup the rank
of each user score.

The scores will be added to the users list.

#+caption: Mapped state properties to the =Leaderboard= component properties
#+begin_src js
  function userScore(userID, questions) {
    const createdQuestions = questions.reduce(
      (accumulator, question) => (accumulator + (question.author === userID ? 1 : 0)),
      0,
    );
    const answeredQuestions = questions.reduce(
      (accumulator, question) => {
        const answered = question.optionOne.votes.includes(userID)
              || question.optionTwo.votes.includes(userID);

        return accumulator + answered;
      },
      0,
    );

    return {
      answeredQuestions,
      createdQuestions,
      score: answeredQuestions + createdQuestions,
    };
  }
  function mapStateToProps({ questions, users }) {
    const questionList = Object.values(questions);
    const userWithScore = Object.values(users).map((user) => ({
      ...user,
      ...userScore(user.id, questionList),
    })).sort((a, b) => b.score - a.score);

    // Remove duplicates
    const scores = [...new Set(userWithScore.map((user) => user.score))];
    const userWithRank = userWithScore.map((user) => ({
      ...user,
      rank: scores.indexOf(user.score) + 1,
    }));

    return {
      users: userWithRank,
    };
  }
#+end_src
**** Tree of =Leaderboard=
The following components components will be children of =Leaderboard=
 - =LoginRequired= for authentication
   - =Body= for layout
     - A list of =UserCard= for each user.

#+begin_src plantuml :file images/leaderboard_component_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Tree structure of component: ""Leaderboard""
  left to right direction

  rectangle Leaderboard [
  ""**Leaderboard**""
  ]
  rectangle LoginRequired [
  ""**LoginRequired**""
  ]
  rectangle Body [
  ""**Body**""
  ]
  rectangle UserCards [
  ""**UserCard[]**""
  ]
  rectangle UserCard [
  ""**UserCard**""
  ==
  === Passed Props:
  ..
  ""string"" : ""name""
  ..
  ""string"" : ""avatarURL""
  ..
  ""string[]"" : ""answeredQuestions""
  ..
  ""string[]"" : ""createdQuestions""
  ..
  ""number"" : ""rank""
  ..
  ""string"" : ""link""
  ..
  ""string"" : ""key""
  ]

  Leaderboard --> LoginRequired
  LoginRequired --> Body
  Body --> UserCards
  UserCards --> UserCard
#+end_src

#+caption: Structure of =Leaderboard= component
#+RESULTS:
[[file:images/leaderboard_component_structure.png]]

*** =NewQuestion= Component
The =NewQuestion= component will contain a form of two field to post a
new ~would you rather~ question.  Unless both text input are not void
(excluding blank chars), the submit button will not work.

The component will be a class component in order to use /React/ state.
Both input will be controlled by the component.
**** Overview
#+caption: Mockup of =NewQuestion= component
#+RESULTS:
[[file:images/newquestion_overview.png]]

This is the view of the =NewQuestion= component.

1. is a =Body= component
2. is a =OptionOrOptionForm= component
3. is a =OptionTextInput= that is part of =OptionOrOptionForm=

**** Data of =NewQuestion=
The component will be a connected component to make use of the
=dispatch= function.

The properties mapped (as =mapDispatchToProps=) will be the following:
 - =push=
   - an action creator to redirect the user to the home page

The component will contain two state member
 - =option1=
   - A =string= to capture the first option the user entered.  This
     means this component will control an input down the tree.
 - =option2=
   - An other =string= to capture the second option.  Also controlling
     an input.

#+begin_src plantuml :file images/newquestion_component_data.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Data of component: ""NewQuestion""
  left to right direction

  class NewQuestion {
      + NewQuestion : constructor()
      - void : handleOptionOneChange(event)
      - void : handleOptionTwoChange(event)
      - bool : isValidQuestion()
      == State props ==
      - string : option1
      - string : option2
      == Connected Props ==
      - Function : push
  }
#+end_src

#+caption: Data of =NewQuestion= component
#+RESULTS:
[[file:images/newquestion_component_data.png]]

**** Behaviour of =NewQuestion=
The component will contain member functions to manage its behaviour:
 - =handleOptionOneChange=: to handle the input change.  This really
   means, controlling an input component
 - =handleOptionTwoChange=: same as the preceding function but for the
   second option
 - =isValidQuestion=: a predicate to check that both =option1= and
   =option2= are not empty when applying the =String.prototype.trim=
   method on them

#+caption: Behaviour of =NewQuestion= component
#+begin_src js
  class NewQuestion extends Component {
    constructor(...args) {
      super(...args);

      this.state = {
        option1: '',
        option2: '',
      };
    }

    handleOptionOneChange = (ev) => {
      const { value } = ev.target;

      this.setState(() => ({
        option1: value,
      }));
    }

    handleOptionTwoChange = (ev) => {
      const { value } = ev.target;

      this.setState(() => ({
        option2: value,
      }));
    }

    isValidQuestion = () => {
      const {
        option1,
        option2,
      } = this.state;

      return option1.trim() !== '' && option2.trim() !== '';
    }
    render() {
      // Render method
    }
  }
#+end_src

**** Tree of =NewQuestion=
The following components components will be children of =NewQuestion=
 - =LoginRequired= for authentication
   - =Body= for layout
     - =OptionOrOptionForm= containing the form.  An options property
       will be passed to the =OptionOrOptionForm= component containing
       option one and option two.

#+begin_src plantuml :file images/newquestion_component_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Tree structure of component: ""NewQuestion""
  left to right direction

  rectangle Home [
  ""**NewQuestion**""
  ]
  rectangle Body [
  ""**Body**""
  ]
  rectangle OptionOrOptionForm [
  ""**OptionOrOptionForm**""
  ==
  === Passed Props:
  ..
  ""string"" : ""title""<size:13> = “Create New Question”
  ..
  ""string"" : ""subtitle""<size:13> = “Would you rather …”
  ..
  ""Option[]"" : ""options""
  <size:13>List of options
  ..
  ""function"" : ""isValidForm""
  <size:13>Predicate to test if it’s a valid form
  ..
  ""function"" : ""onSubmit""
  <size:13>Callback for form submission
  ]

  class Option {
      ""string : placeholder""
      ""string : value""
      ""function : onChange""
      ""string : key""
  }

  Option --* OptionOrOptionForm
  Home --> Body
  Body --> OptionOrOptionForm
#+end_src

#+caption: Structure of =NewQuestion= component
#+RESULTS:
[[file:images/newquestion_component_structure.png]]

*** =SignIn= Component
The =SignIn= component will contain a dropdown button to sign-in.  The
list of users will be displayed in the dropdown allowing to signin
without typing the user name.  However, this functionality will be
delegated to a child component, namely =UserSelector=.

This component will be a connected component to the Redux store.  The
following Redux state properties will be used for mapping:
 - =authedUser=

The =authedUser= property will be needed to change the location when
its value is not null.  The user will be redirected to the =HomePage=.

**** Overview
#+caption: Mockup of =SignIn= component
#+RESULTS:
[[file:images/signin_overview.png]]

This is the view of the =SignIn= component.

1. is a =Body= component
2. is a =Label= component containing a =Header= that also contains a
   =Header.Subheader=
3. is an =Image= component
4. is a =Header= component
5. is a =UserSelector= component.  Note that the parent (not shown) is
   a =Form=
6. is a =Button= component that is also a child of the =Form=

**** Tree of =SignIn=
The following components components will be children of =SignIn=
 - =Body= for layout
   - =Label= for displaying an attached header (full-width)
     - =Header= as =h3= for displaying a welcome message
       - =Header.Subheader= for asking the user to sign-in
   - =Image= for displaying the app logo
   - =Header= as =h2= to show the text: ~Sign in~
   - =Form= to handle the submission
     - =Form.Field=
       - =UserSelector= that is a dropdown menu for selecting a user
     - =Form.Field=
       - =Button= that is a =type= of =submit=.  The button will be
         disabled by default, but when a valid user is selected, will
         be enabled.

#+begin_src plantuml :file images/signin_component_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Tree structure of component: ""SignIn""
  left to right direction

  rectangle SignIn [
  ""**SignIn**""
  ]
  rectangle Body [
  ""**Body**""
  ]
  rectangle Label [
  ""**Label**""
  ]
  rectangle Header [
  ""**Header**""
  ]
  rectangle Header.Subheader [
  ""**Header.Subheader**""
  ]
  rectangle Image [
  ""**Image**""
  ]
  rectangle Header2 [
  ""**Header**""
  ]
  rectangle Form [
  ""**Form**""
  ]
  rectangle Form.Field [
  ""**Form.Field**""
  ]
  rectangle UserSelector [
  ""**UserSelector**""
  ]
  rectangle Form.Field2 [
  ""**Form.Field**""
  ]
  rectangle Button [
  ""**Button[type="submit"]**""
  ]

  SignIn --> Body
  Body --> Label
  Label --> Header
  Header --> Header.Subheader
  Body --> Image
  Body --> Header2
  Body --> Form
  Form --> Form.Field
  Form.Field --> UserSelector
  Form --> Form.Field2
  Form.Field2 --> Button
#+end_src
#+caption: Structure of SignIn component
#+RESULTS:
[[file:images/signin_component_structure.png]]

**** Data of =SignIn=
The component will contain the following (component) state properties:
 - =submitDisabled= that will disabled the button for submission.  The
   =SelectUser= component used will not allow to submit when clicking
   [Enter] in the field.
 - =loading= that will be passed to the =Form=.  The library used will
   display a loading placeholder instead of the actual form.

The properties mapped will be the following:
 - =authedUser=
   - The same value as in store

#+begin_src plantuml :file images/signin_component_data.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
  }

  title =Data of component: ""Sigin""
  left to right direction

  class SignIn {
      == State props ==
      bool : submitDisabled = true
      bool : loading = false
      == Connected Props ==
      string : authedUser
  }
#+end_src
#+caption: Data of =SignIn= component
#+RESULTS:
[[file:images/signin_component_data.png]]

*** =Question= Component
The =Question= component will display a given question in two form:
 - Answered question where votes are shown
 - Unanswered question where the user has to choose between two
   options

When the given question doesn’t exist, it will redirect to the
=PageNotFound= page.

**** Unanswered question
***** Overview
#+caption: Mockup of an unanswered question
#+RESULTS:
[[file:images/question_unanswered_overview.png]]

1. is a =QuestionChoice= component
2. is a =QuestionCard= component
3. is an =h3= element
4. is an =OptionChoice= component

**** Answered question
***** Overview
#+caption: Mockup of an answered question
#+RESULTS:
[[file:images/question_answered_overview.png]]

1. is an =AnsweredQuestion= component
2. is a =QuestionCard= component
3. is a =PollResults= component

**** Data of =Question=
The properties mapped will be the following:
 - =authedUser=
   - The same value as in store

#+begin_src plantuml :file images/question_component_data.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
  }

  title =Data of component: ""Question""
  left to right direction

  class Question {
      == Connected Props ==
      string : choice
      string : id
      bool : questionNotFound = false
  }
#+end_src
#+caption: Data of =SignIn= component
#+RESULTS:
[[file:images/question_component_data.png]]
***** =Question= mapping operations
The =id= property is given by =match.params.id= provided by
=connected-react-router=.

The =questionNotFound= property will be calculated by checking if the
question ID as peroperty to the =questions= object returns undefined.
If that is the case, nothing else needs to be done (return
immediately).

The =choice= property will be calculated by checking if the
=authedUser= is included in the =optionOne= or =optionTwo= list of
votes. ='a'= for the first and ='b'= for the latter.

#+begin_src js
function mapStateToProps({ questions, authedUser }, { match }) {
  const { id } = match.params;

  if (questions[id] === undefined) {
    return {
      id,
      questionNotFound: true,
    };
  }

  const {
    optionOne,
    optionTwo,
  } = questions[id];
  const choice = (optionOne.votes.includes(authedUser) && 'a')
        || (optionTwo.votes.includes(authedUser) && 'b');

  return {
    choice,
    id,
  };
}
#+end_src

**** Behaviour of =Question=
First, if the question is not found, the user is redirected to
=PageNotFound=.

If the user had a choice recorded, it means she already voted on the
question.  Therefore, the the poll results =AnsweredQuestion= will be
displayed.

Otherwise, the user is shown with form =QuestionChoice= that she may
give a vote.

#+begin_src js
function Question({
  id,
  choice,
  questionNotFound,
}) {
  if (questionNotFound) {
    return <PageNotFound />;
  }

  return (
    <LoginRequired>
      <Body>
        {(choice && (
          <AnsweredQuestion
            id={id}
            choice={choice}
          />
        ))
         || (
           <QuestionChoice
             id={id}
           />
         )}
      </Body>
    </LoginRequired>
  );
}
#+end_src

*** =User= Component
The =User= component will display a given user.

*** =PageNotFound= Component
The =PageNotFound= component will display an error message when a
route doesn’t exist.  This component will be a connected component to
the Redux store.  The following state properties will be used for
mapping:
 - =authedUser=

It will be used to display a message with the user ID.

The following message will be displayed:

#+begin_quote
Hi $USERID!

I’ve been expecting you

 - It may be because you’re lost
 - Or that the page moved somewhere else
 - BUT things aren’t broken, okay?
#+end_quote

**** Tree of =PageNotFound=
The following components components will be children of =PageNotFound=
 - =Body= for layout
   - =Message= for displaying a custom error message
     - =Icon= This will be the ~bug~ icon with a =loading= property.
       The loading property adds an animation to it
     - =Message.Content= for wrapping the message inside a block
       - =Message.Header= for displaying the message header
       - =p= for displaying a message
       - =Message.List= for adding an unordered list
         - Multiple =Message.Item= displaying funny messages

#+begin_src plantuml :file images/pagenotfound_component_structure.png
  skinparam {
      titleBorderRoundCorner 15
      titleBorderThickness 2
      titleBorderColor black
      handwritten true
      shadowing true
      defaultMonospacedFontName Courier
      ArrowColor Olive
  }

  title =Tree structure of component: ""PageNotFound""
  left to right direction

  rectangle PageNotFound [
  ""**Home**""
  ]
  rectangle Body [
  ""**Body**""
  ]
  rectangle Message [
  ""**Message**""
  ]
  rectangle Message.Content [
  ""**Message.Content**""
  ]
  rectangle Message.Header [
  ""**Message.Header**""
  ]
  rectangle p [
  ""**p**""
  ]
  rectangle Message.List [
  ""**Message.List**""
  ]
  rectangle Message.Item1 [
  ""**Message.Item**""
  ]
  rectangle Message.Item2 [
  ""**...**""
  ]
  rectangle Message.Item3 [
  ""**Message.Item**""
  ]


  PageNotFound -> Body
  Body -> Message
  Message --> Message.Content
  Message.Content --> Message.Header
  Message.Content --> p
  Message.Content --> Message.List
  Message.List --> Message.Item1
  Message.List --> Message.Item2
  Message.List --> Message.Item3
#+end_src
#+caption: Structure of PageNotFound component
#+RESULTS:
[[file:images/pagenotfound_component_structure.png]]

** Store setup
In order to setup the store, a new file will be used to initialize the
Redux store.

The =createBrowserHistory= function will be imported from the
=history= package.

The =persistStore= and =persistReducer= will be imported from
=redux-persist= in order to support persistence.  Also, =storage= will
be imported (for =localStorage=) from the same package.

*** Reducers
A new file containing all the reducers will be created at
=./reducers/index.js= in order to import all the reducer.  A single
root reducer will be exported.

#+begin_src js
import { combineReducers } from 'redux';
import { connectRouter } from 'connected-react-router';
import authedUser from './authedUser';
import users from './users';
import questions from './questions';

export default (history) => combineReducers({
  authedUser,
  users,
  questions,
  router: connectRouter(history),
});
#+end_src

The new exported root reducer will be a factory function that takes
the history as argument.  =persistReducer= will be used to create
reducer persistence.

*** Middlewares
A new file containing all the middlewares (or enhancers) will be
created at =./middleware/index.js= in order to support the router
middleware.

#+begin_src js
import { applyMiddleware } from 'redux';
import { composeWithDevTools } from 'redux-devtools-extension';
import { routerMiddleware } from 'connected-react-router';
import thunk from 'redux-thunk';

const composeEnhancers = composeWithDevTools({
  trace: true,
  traceLimit: 25,
});
export default (history) => composeEnhancers(
  applyMiddleware(
    routerMiddleware(history),
    thunk,
  ),
);
#+end_src

*** =configureStore.js=
#+begin_src js
import { createBrowserHistory } from 'history';
import { createStore } from 'redux';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage'; // defaults to localStorage for web
import createRootReducer from './reducers';
import createMiddlewares from './middleware';

export const history = createBrowserHistory();
const persistConfig = {
  key: 'root',
  storage,
};

const rootReducer = createRootReducer(history);
const persistedReducer = persistReducer(persistConfig, rootReducer);

export default function configureStore(preloadedState) {
  const store = createStore(
    persistedReducer,
    preloadedState,
    createMiddlewares(history),
  );
  const persistor = persistStore(store);

  return {
    store,
    persistor,
  };
}
#+end_src

** Main entry file (=index.js=)
The main entry file will make use of the =configureStore= function.
It will also make use of the =PersistGate= component.  =history= must
be imported from =configureStore= in order to pass it to the =App=
component.

Last, =Provider= from =react-redux= will be imported.
** Action creators
*** authedUser
=authedUser= will contain two action creators.

 * =setAuthedUser= that will take an ID and set the current user to
   the new user.
 * =signOut= to sign-out the user.

#+begin_src js
export const SET_AUTHED_USER = 'SET_AUTHED_USER';
export const SIGNOUT_AUTHED_USER = 'SIGNOUT_AUTHED_USER';

export function setAuthedUser(id) {
  return {
    type: SET_AUTHED_USER,
    id,
  };
}

export function signOut() {
  return {
    type: SIGNOUT_AUTHED_USER,
  };
}
#+end_src

*** users
=users= will contain only one action creator.

 * =receiveUsers= to receive the list of users.

#+begin_src js
export const RECEIVE_USERS = 'RECEIVE_USERS';

export function receiveUsers(users) {
  return {
    type: RECEIVE_USERS,
    users,
  };
}
#+end_src

*** questions
=questions= will contain three action creators.

 * =receiveQuestions= to receive the initial data.
 * =answerQuestion= to answer a given question.
 * =addQuestion= to add a new question.

#+begin_src js
export const RECEIVE_QUESTIONS = 'RECEIVE_QUESTIONS';
export const ANSWER_QUESTION = 'ANSWER_QUESTION';
export const ADD_NEW_QUESTION = 'ADD_NEW_QUESTION';

export function receiveQuestions(questions) {
  return {
    type: RECEIVE_QUESTIONS,
    questions,
  };
}

export function answerQuestion(info) {
  return {
    type: ANSWER_QUESTION,
    info,
  };
}

export function addQuestion(indo) {
  return {
    type: ADD_NEW_QUESTION,
    info,
  };
}
#+end_src


*** shared
In order to handle the initial data, a shared file will be created
containing all the action creators for initialization.

#+begin_src js
import { getInitialData } from '../util/api';
import {
  receiveUsers,
} from './users';
import {
  receiveQuestions,
} from './questions';

export default function handleInitialData() {
  return (dispatch) => getInitialData()
    .then(({ users, questions }) => {
      dispatch(receiveUsers(users));
      dispatch(receiveQuestions(questions));
    });
}
#+end_src
